package main

import "app"
import "fps"
import "gam"
import "gfx"
import "gui"
import "mat"
import "snd"
import "phx"

// TODO : can't navigate with keyboard at startup
// TODO : dialog disapear if exit button is pushed with keyboard

// Globals ...
var backwardQuat mat.v4 = mat.QuaternionFromAxisAngle(0.0, 1.0, 0.0, mat.PI)
var yawTime f32 = -1.0
var gameScreen gui.ScreenId
var exitScreen gui.ScreenId

var skyminerModel gfx.ModelId = gfx.ModelInvalid()
var skyminerScale f32 = 0.1
var skyminerPos mat.v3

type Anim struct {
	model gfx.ModelId
	anim gfx.AnimationId
}

type Player struct {
	idle Anim
	throw Anim
	jump Anim
	forward Anim
	backward Anim
	left Anim
	right Anim
	spine i32
	torso i32
	shoulder i32
	hand i32
}

var tmpAnim0 gfx.AnimationId = gfx.AnimationInvalid()
var tmpAnim1 gfx.AnimationId = gfx.AnimationInvalid()
var backward bool

var tmpAnim2 gfx.AnimationId = gfx.AnimationInvalid()

var switchAnimTime f32
var currentAnim gfx.AnimationId = gfx.AnimationInvalid()
var runtimeAnim gfx.AnimationId = gfx.AnimationInvalid()
var previousAnim gfx.AnimationId = gfx.AnimationInvalid()

var playerScale f32 = 0.1
var playerWorld []f32 = gfx.MatrixAlloc()
var players []Player
var currentPlayer i32
var previousPlayer i32
var jumping bool

var groundMesh gfx.MeshId = gfx.InvalidMesh()
var texture gfx.TextureId = gfx.InvalidTexture()
var dollar gfx.TextureId = gfx.InvalidTexture()

var dollarMesh gfx.MeshId = gfx.InvalidMesh()

var skyMesh gfx.MeshId = gfx.InvalidMesh()
var skyDiffuse gfx.TextureId = gfx.InvalidTexture()
var skySpecular gfx.TextureId = gfx.InvalidTexture()
var brdf gfx.TextureId = gfx.InvalidTexture()

var world [] f32 = mat.MatrixAlloc()
var identity [] f32 = mat.MatrixAlloc()
var tmpMatrix []f32 = mat.MatrixAlloc()
var tmpMatrix2 []f32 = mat.MatrixAlloc()
var tmpColor []f32

var camera gam.CameraId

var worldPosY f32 = -10.0

var worldSizeX f32 = 2000.0
var worldSizeZ f32 = 2000.0

var worldCellX i32 = 64
var worldCellZ i32 = 64

var phxPlayer i32
var phxGround0 i32
var phxGround1 i32

var groundScale f32 = 20.0
var groundRight f32 = worldSizeX / groundScale
var groundBack f32 = worldSizeZ / groundScale
var groundWidth i32 = 16
var groundHeight i32 = 16

var voiceId snd.VoiceId

var TAG_GROUND i32 = 1
var TAG_PLAYER i32 = 2
var TAG_MINER i32 = 3
var TAG_DOLLAR i32 = 4
var TAG_AIM i32 = 5

var CAMERA_FREE i32 = 0
var CAMERA_TPS i32 = 1
var CAMERA_FPS i32 = 2
var CAMERA_COUNT i32 = 3
var currentCamera i32 = CAMERA_FPS

var fireWeapon i32 = 0
var fireAnimTime f32 = -1.0
var fireAnimLength f32 = -1.0
var fireAnimThresh f32 = 1.1
var fireAnimThrow f32 = 0.65
var aimPosition mat.v3
var aimMax i32 = 8
var aimCount i32 = 0

var phxRemoveList []i32
var phxSortedList []i32

var WEAPON_SKYNOTE i32 = 0
var WEAPON_SKYMINER i32 = 1
var WEAPON_COUNT i32 = 2

var currentWeapon i32 = WEAPON_SKYMINER

var xdir f32
var ydir f32
var zdir f32

var MOVE_ i32 = 0
var MOVE_TX i32 = 0
var MOVE_TY i32 = 1
var MOVE_TZ i32 = 2
var MOVE_R i32 = 3
var MOVE_COUNT i32 = 4
var ffx f32
var ffy f32
var ffz f32
var ffr f32
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func gameOnEvent(controlIndex i32, controlAction i32) {
	var key i32 = gui.CurrentEvent.keyboard.key
	var action i32 = gui.CurrentEvent.keyboard.action
	var mods i32 = gui.CurrentEvent.keyboard.mods

	if mods == app.MOD_CTRL {
		if action == app.KEY_PRESS {
			if key == app.KEYCODE_LEFT {
				if action == app.KEY_PRESS {
					currentPlayer = currentPlayer - 1
					if currentPlayer < 0 {
						currentPlayer = len(players) - 1
					}
				}
			} else if key == app.KEYCODE_RIGHT {
				if action == app.KEY_PRESS {
					currentPlayer = currentPlayer + 1
					if currentPlayer >= len(players) {
						currentPlayer = 0
					}
				}
			} else if key == app.KEYCODE_UP {
				MOVE_ = MOVE_ + 1
				MOVE_ = MOVE_ % MOVE_COUNT
				if MOVE_ == MOVE_TX {
					printf("-----------TRANSLATE XXX\n")
				} else if MOVE_ == MOVE_TY {
					printf("-----------TRANSLATE YYY\n")
				} else if MOVE_ == MOVE_TZ {
					printf("-----------TRANSLATE ZZZ\n")
				} else if MOVE_ == MOVE_R {
					printf("-----------ROTATE\n")
				}
			} else if key == app.KEYCODE_DOWN {
				MOVE_ = MOVE_ - 1
				if MOVE_ < 0 {
					MOVE_ = MOVE_COUNT
				}
				if MOVE_ == MOVE_TX {
					printf("-----------TRANSLATE XXX\n")
				} else if MOVE_ == MOVE_TY {
					printf("-----------TRANSLATE YYY\n")
				} else if MOVE_ == MOVE_TZ {
					printf("-----------TRANSLATE ZZZ\n")
				} else if MOVE_ == MOVE_R {
					printf("-----------ROTATE\n")
				}
			}
		}
	} else if mods == app.MOD_SHIFT {
		if action == app.KEY_PRESS {
			if key == app.KEYCODE_LEFT {
				if action == app.KEY_PRESS {
					currentCamera = currentCamera - 1
					if currentCamera < 0 {
						currentCamera = CAMERA_COUNT - 1
					}
				}
			} else if key == app.KEYCODE_RIGHT {
				if action == app.KEY_PRESS {
					currentCamera = currentCamera + 1
					if currentCamera >= CAMERA_COUNT {
						currentCamera = 0
					}
				}
			}
		}

		if key == app.KEYCODE_UP {
			if MOVE_ == MOVE_TX {
				ffx = ffx + 0.1
			} else if MOVE_ == MOVE_TY {
				ffy = ffy + 0.01
			} else if MOVE_ == MOVE_TZ {
				ffz = ffz + 0.1
			} else if MOVE_ == MOVE_R {
				ffr = ffr + 0.02
			}
			printf("tx %f, ty %f, tz %f, r %f\n", ffx, ffy, ffz, ffr)
		} else if key == app.KEYCODE_DOWN {
			if MOVE_ == MOVE_TX {
				ffx = ffx - 0.1
			} else if MOVE_ == MOVE_TY {
				ffy = ffy - 0.01
			} else if MOVE_ == MOVE_TZ {
				ffz = ffz - 0.1
			} else if MOVE_ == MOVE_R {
				ffr = ffr - 0.02
			}
			printf("tx %f, ty %f, tz %f, r %f\n", ffx, ffy, ffz, ffr)
		}
	} else if mods == app.MOD_NONE {
   		if key == app.KEYCODE_LEFT || key == app.KEYCODE_A {
			if action == app.KEY_PRESS {
				switchAnimTime = -1.0
				previousAnim = currentAnim
				zdir = -1.0
			} else if action == app.KEY_RELEASE {
				switchAnimTime = -1.0
				previousAnim = currentAnim
				zdir = 0.0
			}
		} else if key == app.KEYCODE_RIGHT || key == app.KEYCODE_D {
			if action == app.KEY_PRESS {
				switchAnimTime = -1.0
				previousAnim = currentAnim
				zdir = 1.0
			} else if action == app.KEY_RELEASE {
				switchAnimTime = -1.0
				previousAnim = currentAnim
				zdir = 0.0
			}
		} else if key == app.KEYCODE_UP || key == app.KEYCODE_W {
			if action == app.KEY_PRESS {
				switchAnimTime = -1.0
				previousAnim = currentAnim
				xdir = -1.0
			} else if action == app.KEY_RELEASE {
				switchAnimTime = -1.0
				previousAnim = currentAnim
				xdir = 0.0
			}
		} else if key == app.KEYCODE_DOWN || key == app.KEYCODE_S {
			if action == app.KEY_PRESS {
				switchAnimTime = -1.0
				previousAnim = currentAnim
				xdir = 1.0
			} else if action == app.KEY_RELEASE {
				switchAnimTime = -1.0
				previousAnim = currentAnim
				xdir = 0.0
			}
		} else if key == app.KEYCODE_SPACE {
			if action == app.KEY_PRESS {
				if currentWeapon == WEAPON_SKYNOTE {
					fireWeapon = 1
				} else if currentWeapon == WEAPON_SKYMINER {
					fireWeapon = 1
				}
			} else if action == app.KEY_RELEASE {
				//fireWeapon = 0
			}
		} else if key == app.KEYCODE_V {
			if phx.COLLIDED == true {
				ydir = 1.0
				jumping = true
			}
		} else if key == app.KEYCODE_1 {
			if action == app.KEY_PRESS {
				currentWeapon = WEAPON_SKYMINER
			}
		} else if key == app.KEYCODE_2 {
			if action == app.KEY_PRESS {
				currentWeapon = WEAPON_SKYNOTE
			}
		}
	}

	var mouseAction i32 = gui.CurrentEvent.mouse.action
	var mouseButton i32 = gui.CurrentEvent.mouse.button
	if mouseAction == app.MOUSE_PRESS && mouseButton == app.BUTTON_LEFT {
	}

	if mouseAction == app.MOUSE_MOVE {
	var mousePosition mat.v2 = gui.CurrentEvent.mouse.position
		aimPosition = mat.v3_(2.0 * mousePosition.x / gfx.gfx_width - 1.0, 2.0 * mousePosition.y / gfx.gfx_height - 1.0, 0.0)
	}

	if currentCamera == CAMERA_FREE {
		gam.FreeCameraProcess(camera, &gui.CurrentEvent)
	} else if currentCamera == CAMERA_FPS {
		gam.FpsCameraProcess(camera, &gui.CurrentEvent)
	} else if currentCamera == CAMERA_TPS {
		gam.TpsCameraProcess(camera, &gui.CurrentEvent)
	}
}

func newAimBox(position mat.v3) {
	var objType i32 = phx.TYPE_BOX
	var objTag i32 = TAG_AIM

	var state i32 = phx.STATE_TRANSLATE | phx.STATE_DEBUG

	var axis mat.v3 = mat.v3_normalize(mat.v3_rand())

	var mass f32 = 1.0

	var min mat.v3 = mat.v3_(-1.0, -1.0, -1.0)
	var max mat.v3 = mat.v3_(1.0, 1.0, 1.0)
	var radius f32 = 2.5

	var right mat.v3 = mat.v3_(radius * (max.x - min.x), 0.0, 0.0)
	var top mat.v3 = mat.v3_(0.0, radius * (max.y - min.y), 0.0)
	var back mat.v3 = mat.v3_(0.0, 0.0, radius * (max.z - min.z))


	var miner i32 = phx.AddObject(objType, objTag, state, position, mat.v3_(0.0, f32.rand() * 10.0, 0.0), mat.v3_(0.0, 0.0, 0.0),
		right, top, back, mass, 0.01, mat.v4_(0.0, 1.0, 0.0, 0.0),
		mat.v4_(f32.rand(), f32.rand(), f32.rand(), 1.0))
}


func fireSkyminer(position mat.v3, direction mat.v3) {
	var objType i32 = phx.TYPE_BOX
	var objTag i32 = TAG_MINER

	var state i32 = phx.STATE_TRANSLATE | phx.STATE_ROTATE

	var axis mat.v3 = mat.v3_normalize(mat.v3_rand())

	var mass f32 = 5.0
	var force f32 = 400.0

	var min mat.v3 = gfx.ModelGetMin(skyminerModel)
	var max mat.v3 = gfx.ModelGetMax(skyminerModel)
	var radius f32 = skyminerScale * 0.51

	var right mat.v3 = mat.v3_(radius * (max.x - min.x), 0.0, 0.0)
	var top mat.v3 = mat.v3_(0.0, radius * (max.y - min.y), 0.0)
	var back mat.v3 = mat.v3_(0.0, 0.0, radius * (max.z - min.z))

	var acceleration mat.v3 = mat.v3_mulf(direction, force / mass)

	var miner i32 = phx.AddObject(objType, objTag, state, position, acceleration, mat.v3_(0.0, 0.0, 0.0),
		right, top, back, mass, 0.96, mat.v4_(axis.x, axis.y, axis.z, f32.rand() * 10.0), mat.v4_(1.0, 1.0, 1.0, 1.0))
}

func fireSkynotes(position mat.v3, direction mat.v3) {

	var objType i32 = phx.TYPE_PLANE
	var objTag i32 = TAG_DOLLAR

	var state i32 = phx.STATE_TRANSLATE | phx.STATE_ROTATE

	var mass f32 = 0.01

	var skynoteCount i32 = i32.rand(1, 10)
	for i := 0; i < skynoteCount; i++ {
		var at mat.v3 = mat.v3_normalize(mat.v3_add(direction, mat.v3_(f32.rand() * 0.2 - 0.1, f32.rand() * 0.2 - 0.1, f32.rand() * 0.2 - 0.1)))
		var axis mat.v3 = mat.v3_normalize(mat.v3_rand())

		var force f32 = 10.0 + f32.rand() * 1.0
		var right mat.v3 = mat.v3_(0.5 + f32.rand() * 0.5, 0.0, 0.0)
		var top mat.v3 = mat.v3_(0.0, 0.5 + f32.rand() * 0.5, 0.0)
		var back mat.v3 = mat.v3_(0.0, 0.0, 0.5 + f32.rand() * 0.5)

		var acceleration mat.v3 = mat.v3_mulf(at, force / mass)

		var miner i32 = phx.AddObject(objType, objTag, state, position, mat.v3_(0.0, 0.0, 0.0), acceleration,
			right, top, back, mass, 1.0, mat.v4_(axis.x, axis.y, axis.z, f32.rand() * 10.0), mat.v4_(1.0, 1.0, 1.0, 1.0))
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var firstUpdate bool = false
func gameOnUpdate(controlIndex i32, controlAction i32) {
	// >> HACK : start cx profiling
	if firstUpdate == false {
		firstUpdate = true
		debugI32(0)
	}
	// << HACK : start cx profiling


	var scaleBox f32 = 50.0
	for i:= aimCount; i < aimMax; i++ {
		newAimBox(mat.v3_add(mat.v3_((2.0 * f32.rand() - 1.0) * scaleBox, scaleBox + f32.rand() * 5.0, (2.0 * f32.rand() - 1.0) * scaleBox), phx.GetObjectPosition(phxPlayer)))
		aimCount = aimCount + 1
	}

	var playerAt mat.v3 = phx.GetObjectAt(phxPlayer)
	var playerOffset mat.v3 = mat.v3_add(mat.v3_mulf(playerAt, 0.4), mat.v3_(1.2 + 4.0, 16.9 + 3.7, 0.2 + 0.4))
 
	var cameraAt mat.v3 = gam.CameraGetAt(camera)
	var cameraPos mat.v3 = gam.CameraGetPosition(camera)

	var dts f64 = fps.DeltaSecond()
	var dt f32 = f64.f32(dts)

	var player Player = players[currentPlayer]
	fireAnimLength = gfx.AnimationGetMax(player.throw.anim)

	var weaponAt mat.v3
	var weaponPos mat.v3 = skyminerPos
	if currentCamera == CAMERA_FREE {
		weaponAt = cameraAt
	} else if currentCamera == CAMERA_TPS {
		var invProj[]f32 = gam.CameraGetInvViewProj(camera)
		var aimDir mat.v4 = mat.v4_(aimPosition.x, aimPosition.y, 1.0, 1.0)
		aimDir = mat.v4_transform(aimDir, invProj)
		var weaponTarget mat.v3
		weaponTarget.x = aimDir.x / aimDir.w
		weaponTarget.y = aimDir.y / aimDir.w
		weaponTarget.z = aimDir.z / aimDir.w
		weaponAt = weaponTarget
		weaponAt = mat.v3_sub(weaponTarget, mat.v3_add(phx.GetObjectPosition(phxPlayer), playerOffset))
		weaponAt = mat.v3_normalize(weaponAt)

		var cameraYaw mat.v4 = gam.CameraGetYawQuaternion(camera)
		var playerYawAA mat.v4 = phx.GetObjectRotation(phxPlayer)
		var playerYaw mat.v4 = mat.QuaternionFromAxisAngle(playerYawAA.x, playerYawAA.y, playerYawAA.z, playerYawAA.w)

		var yawLength f32 = mat.v4_length(mat.v4_sub(cameraYaw, playerYaw))
		if yawLength < 0.001 {
			yawTime = -1.0
			playerYaw = cameraYaw
		} else {
			if yawTime < 0.0 {
				yawTime = 0.0
			}
			playerYaw = mat.QuaternionLerp(playerYaw, cameraYaw, yawTime)
			yawTime = yawTime + dt
			if yawTime > 1.0 {
				yawTime = -1.0
			}
		}

		playerYaw = mat.QuaternionToAxisAngle(playerYaw.x, playerYaw.y, playerYaw.z, playerYaw.w)
		phx.SetObjectRotation(phxPlayer, playerYaw)
	} else if currentCamera == CAMERA_FPS {
		weaponAt = cameraAt
	}

	var backwardAnim gfx.AnimationId = player.backward.anim
	currentAnim = player.idle.anim
	if previousPlayer != currentPlayer {
		previousAnim = currentAnim
		switchAnimTime = -1.0
	}


	if fireWeapon > 0 && fireAnimTime < 0.0 {
		fireAnimTime = 0.0
		gfx.AnimationSetTime(player.throw.anim, 0.0)
	}


	var acceleration mat.v3
	var at mat.v3
	var right mat.v3


	if currentCamera == CAMERA_FREE {
	} else if currentCamera == CAMERA_FPS {
		if xdir != 0.0 {
			at = playerAt
		}
		if zdir != 0.0 {
			right = phx.GetObjectRight(phxPlayer)
		}

	} else if currentCamera == CAMERA_TPS {
		if xdir != 0.0 {
			at = gam.CameraGetAt(camera)
		}
		if zdir != 0.0 {
			right = gam.CameraGetRight(camera)
		}
	}

	var nextFireAnimTime f32 = fireAnimTime + dt * 2.5
	if nextFireAnimTime >= fireAnimThrow && fireWeapon > 0 {
		if currentWeapon == WEAPON_SKYMINER {
			fireSkyminer(weaponPos, weaponAt)
			fireWeapon = 0
		} else if currentWeapon == WEAPON_SKYNOTE {
			fireSkynotes(weaponPos, weaponAt)
		}
	}

	backward = false
	previousPlayer = currentPlayer
	if currentCamera == CAMERA_FPS || currentCamera == CAMERA_TPS {
		if zdir > 0.0 {
			currentAnim = player.right.anim
		} else if zdir < 0.0 {
			currentAnim = player.left.anim
		}

		if xdir > 0.0 {
			currentAnim = backwardAnim
			backward = true
		} else if xdir < 0.0 {
			currentAnim = player.forward.anim
		}

		var currentDt f32 = dt
		if fireAnimTime >= 0.0 {
			currentAnim = player.throw.anim
			currentDt = dt * 2.5
			fireAnimTime = fireAnimTime + currentDt
		}

		if fireAnimTime > fireAnimLength {
			fireAnimTime = -1.0
		}

		if jumping {
			currentAnim = player.jump.anim
		}
		if currentAnim.animation != previousAnim.animation && switchAnimTime < 0.0 {
			switchAnimTime = 0.0
		}

		if switchAnimTime >= 0.0 {
			var animMax f32 = f32.max(gfx.AnimationGetMax(currentAnim), gfx.AnimationGetMax(runtimeAnim))
			var tmpAnim gfx.AnimationId = tmpAnim0
			if tmpAnim.animation == currentAnim.animation || tmpAnim0.animation == runtimeAnim.animation {
				tmpAnim = tmpAnim1
			}
			if tmpAnim1.animation == currentAnim.animation || tmpAnim1.animation == runtimeAnim.animation {
				tmpAnim = tmpAnim2
			}
		   gfx.AnimationUpdate(currentAnim, currentDt, true, -1.0)//animMax)
			if currentAnim.animation == backwardAnim.animation && currentPlayer == 0 {
				var q mat.v4 = gfx.AnimationGetJointRotation(currentAnim, player.spine)
				q = mat.QuaternionMultiply(q, backwardQuat)
				gfx.AnimationSetJointRotation(currentAnim, player.spine, q)
			}

			gfx.AnimationUpdate(runtimeAnim, dt, true, -1.0)//animMax)
			if runtimeAnim.animation == backwardAnim.animation && currentPlayer == 0{
				var q mat.v4 = gfx.AnimationGetJointRotation(runtimeAnim, player.spine)
				q = mat.QuaternionMultiply(q, backwardQuat)
				gfx.AnimationSetJointRotation(runtimeAnim, player.spine, q)
			}

			gfx.AnimationMorph(runtimeAnim, currentAnim, tmpAnim, switchAnimTime)
			switchAnimTime = switchAnimTime + dt * 5.0
			//currentAnim = tmpAnim
			runtimeAnim = tmpAnim
		} else {
			gfx.AnimationUpdate(currentAnim, currentDt, true, -1.0)
			if currentAnim.animation == backwardAnim.animation && currentPlayer == 0 {
				var q mat.v4 = gfx.AnimationGetJointRotation(currentAnim, player.spine)
				q = mat.QuaternionMultiply(q, backwardQuat)
				gfx.AnimationSetJointRotation(currentAnim, player.spine, q)
			}
			runtimeAnim = currentAnim
		}

		if switchAnimTime >= 1.0 {
			switchAnimTime = -1.0
			previousAnim = currentAnim
			runtimeAnim = currentAnim
			//currentAnim = nextAnim
		}
	}

	acceleration = mat.v3_add(acceleration, mat.v3_mulf(at, dt * 60.0 * xdir))
	acceleration = mat.v3_add(acceleration, mat.v3_mulf(right, dt * 60.0 * zdir))
	acceleration.y = ydir * dt * 500.0
	ydir = 0.0

	phx.SetObjectAcceleration(phxPlayer, acceleration)
	var playerVelocity mat.v3 = phx.GetObjectVelocity(phxPlayer)
	var playerVelocityLength f32 = mat.v3_length(playerVelocity)
	/*var maxVelocity f32 = 200.0
	if playerVelocityLength > maxVelocity {
		playerVelocity = mat.v3_mulf(playerVelocity, maxVelocity / playerVelocityLength)
	}*/
	phx.SetObjectVelocity(phxPlayer, playerVelocity)
	phx.Update(fps.DeltaNano())

	if phx.COLLIDED {
		jumping = false
	}

	var playerPosition mat.v3 = mat.v3 = mat.v3_add(playerOffset, phx.GetObjectPosition(phxPlayer))
	if currentCamera == CAMERA_FREE {
		gam.FreeCameraUpdate(camera, dts)
	} else if currentCamera == CAMERA_FPS {
		gam.FpsCameraUpdate(camera, dts, playerPosition)
	} else if currentCamera == CAMERA_TPS {
		gam.TpsCameraUpdate(camera, dts, playerPosition, 30.0)
	}


	phxRemoveList = resize(phxRemoveList, 0)

	var phxCount i32 = phx.GetObjectCount()
	for i := 0; i < phxCount; i++ {
		var objTag i32 = phx.GetObjectTag(i)
		if objTag == TAG_MINER || objTag == TAG_DOLLAR || objTag == TAG_AIM {
			var position mat.v3 = phx.GetObjectPosition(i)
			if position.y < worldPosY * 2.0 {
				if objTag == TAG_AIM {
					phxRemoveList = append(phxRemoveList, i)
					aimCount = aimCount - 1
				}
			} else if objTag == TAG_MINER {
				for k := 0; k < phxCount; k++ {
					if phx.GetObjectTag(k) == TAG_AIM {
						var distance f32 = mat.v3_length(mat.v3_sub(phx.GetObjectPosition(i), phx.GetObjectPosition(k)))
						if distance < 10.0 || len(phxRemoveList) == 1 {
							phxRemoveList = append(phxRemoveList, k)
							phxRemoveList = append(phxRemoveList, i)
							aimCount = aimCount - 1
						}
					}
				}
			}
		}
	}

	phxSortedList = resize(phxSortedList, 0)
	var removeCount i32 = len(phxRemoveList)
	for i := 0; i < removeCount; i++ {
		var sortedCount i32 = len(phxSortedList)
		var remove i32 = phxRemoveList[i]
		var duplicate i32 = 0
		for k := 0; k < sortedCount; k++ {
			var sorted i32 = phxSortedList[k]
			if remove < sorted {
				phxSortedList = insert(phxSortedList, k, remove)
				k = sortedCount
			} else if remove == sorted {
				duplicate = 1
			} else {
				k = sortedCount
			}
		}

		if sortedCount == len(phxSortedList) && duplicate == 0 {
			phxSortedList = append(phxSortedList, remove)
		}
	}

	for i := 0; i < removeCount; i++ {
		phx.RemoveObject(phxSortedList[removeCount - i - 1])
	}

	gfx.ModelUpdate(skyminerModel, gfx.AnimationInvalid(), dt, true)

	var currentModel gfx.ModelId = players[currentPlayer].idle.model
	gfx.ModelUpdate(currentModel, runtimeAnim, dt, true)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func gameOnRender(controlIndex i32, controlAction i32) {
	var view []f32 = gam.CameraGetView(camera)
	var projection []f32 = gam.CameraGetProjection(camera)
	var cameraPosition mat.v3 = gam.CameraGetPosition(camera)

	gfx.DisableBlending()
	gfx.DepthState(true, gfx.LESS, true)
	gfx.Clear(gfx.COLOR_BUFFER_BIT | gfx.DEPTH_BUFFER_BIT, mat.v4_(0.3, 0.5, 0.6, 1.0), 1.0D, 0)

	//sky
	gfx.EffectUse(gfx.g_fxSky)
	gfx.EffectAssignTexture(gfx.g_fxSky, gfx.SAMPLER_ENV_DIFFUSE, skySpecular, gfx.g_linearWrap)
	gfx.EffectAssignMatrix4(gfx.g_fxSky, gfx.UNIFORM_WORLD, identity, false)
	gfx.EffectAssignMatrix4(gfx.g_fxSky, gfx.UNIFORM_VIEW, view, false)
	gfx.EffectAssignMatrix4(gfx.g_fxSky, gfx.UNIFORM_PROJECTION, projection, false)
	gfx.MeshRender(skyMesh)

	// ground
	gfx.EffectUse(gfx.g_fxTexture3D)
	gfx.EffectAssignTexture(gfx.g_fxTexture3D, gfx.SAMPLER_COLOR_0, texture, gfx.g_linearWrap)
	gfx.EffectAssignMatrix4(gfx.g_fxTexture3D, gfx.UNIFORM_VIEW, view, false)
	gfx.EffectAssignMatrix4(gfx.g_fxTexture3D, gfx.UNIFORM_PROJECTION, projection, false)
	var pos mat.v3 = phx.GetObjectPosition(phxGround0)
	var rot mat.v4 = phx.GetObjectRotation(phxGround0)
	var quat mat.v4 = mat.QuaternionFromAxisAngle(rot.x, rot.y, rot.z, rot.w)
	world = mat.MatrixCreate2(world, 1.0, 1.0, 1.0, quat.x, quat.y, quat.z, quat.w, pos.x, pos.y, pos.z)
	gfx.EffectAssignMatrix4(gfx.g_fxTexture3D, gfx.UNIFORM_WORLD, world, false)
	gfx.MeshRender(groundMesh)
	pos = phx.GetObjectPosition(phxGround1)
	rot = phx.GetObjectRotation(phxGround1)
	quat = mat.QuaternionFromAxisAngle(rot.x, rot.y, rot.z, rot.w)
	world = mat.MatrixCreate2(world, 1.0, 1.0, 1.0, quat.x, quat.y, quat.z, quat.w, pos.x, pos.y, pos.z)
	gfx.EffectAssignMatrix4(gfx.g_fxTexture3D, gfx.UNIFORM_WORLD, world, false)
	gfx.MeshRender(groundMesh)

	// physics
	phx.Render(identity, view, projection)

	// player
	var player Player = players[currentPlayer]
	var currentModel gfx.ModelId = player.idle.model
	gfx.ModelSetView(currentModel, view)
	gfx.ModelSetProjection(currentModel, projection)
	gfx.ModelSetEnvironmentSpecular(currentModel, skySpecular)
	gfx.ModelSetEnvironmentDiffuse(currentModel, skyDiffuse)
	gfx.ModelSetBRDF(currentModel, brdf)
	gfx.ModelSetCameraPosition(currentModel, cameraPosition)
	pos = phx.GetObjectPosition(phxPlayer)
	rot = phx.GetObjectRotation(phxPlayer)
	quat = mat.QuaternionFromAxisAngle(rot.x, rot.y, rot.z, rot.w)
	quat = mat.QuaternionMultiply(quat, mat.QuaternionFromAxisAngle(0.0, 1.0, 0.0, mat.PI))
	playerWorld = mat.MatrixCreate2(playerWorld, playerScale, playerScale, playerScale, quat.x, quat.y, quat.z, quat.w, pos.x, pos.y, pos.z)
	gfx.ModelSetWorld(currentModel, playerWorld)
	gfx.ModelRender(currentModel)

	// skyminers
	gfx.ModelSetView(skyminerModel, view)
	gfx.ModelSetProjection(skyminerModel, projection)
	gfx.ModelSetEnvironmentSpecular(skyminerModel, skySpecular)
	gfx.ModelSetEnvironmentDiffuse(skyminerModel, skyDiffuse)
	gfx.ModelSetBRDF(skyminerModel, brdf)
	gfx.ModelSetCameraPosition(skyminerModel, cameraPosition)

	var tmpRot mat.v4 = mat.QuaternionFromAxisAngle(1.0, 0.0, 0.0,  -0.94)
	var tmpScaleMatrix []f32 = mat.MatrixCreate2(tmpMatrix2, skyminerScale, skyminerScale, skyminerScale, tmpRot.x, tmpRot.y, tmpRot.z, tmpRot.w, -1.4, 22.6, 3.6)
	tmpMatrix = gfx.ModelGetNodeTransform(currentModel, player.hand, tmpMatrix)
	tmpMatrix = mat.MatrixMultiply(tmpMatrix, tmpMatrix, playerWorld)
	tmpMatrix = mat.MatrixMultiply(tmpMatrix, tmpScaleMatrix, tmpMatrix)
	gfx.ModelSetWorld(skyminerModel, tmpMatrix)
	skyminerPos.x = tmpMatrix[12]
	skyminerPos.y = tmpMatrix[13]
	skyminerPos.z = tmpMatrix[14]

	if fireAnimTime >= 0.0 {
		gfx.EnableBlending(gfx.SRC_ALPHA, gfx.ONE_MINUS_SRC_ALPHA)
		gfx.DepthState(true, gfx.LESS, true)
		var fireAnimAlpha f32 = 1.0
		if fireAnimTime >= fireAnimThrow && fireAnimTime <= fireAnimThresh {
			fireAnimAlpha = 0.0
		} else if fireAnimTime >= fireAnimThresh {
			fireAnimAlpha = (fireAnimTime - fireAnimThresh) / (fireAnimLength - fireAnimThresh)
		}
		gfx.modelRender(skyminerModel, gfx.ModelGetMeshes(skyminerModel), fireAnimAlpha)
	} else {
		gfx.ModelRender(skyminerModel)
	}

	for i := 0; i < phx.GetObjectCount(); i++ {
		if phx.GetObjectTag(i) == TAG_MINER {
			pos = phx.GetObjectPosition(i)
			rot = phx.GetObjectRotation(i)
			quat = mat.QuaternionFromAxisAngle(rot.x, rot.y, rot.z, rot.w)
			var minerScale f32 = skyminerScale * 0.1
			world = mat.MatrixCreate2(world, minerScale, minerScale, minerScale, quat.x, quat.y, quat.z, quat.w, pos.x, pos.y, pos.z)
			gfx.ModelSetWorld(skyminerModel, world)
			gfx.ModelRender(skyminerModel)
		}
	}


	// skynotes
	var size mat.v3 = mat.v3_mulf(mat.v3_(1.0, 1.0, 0.5), 0.75)
	gfx.MeshBegin(dollarMesh)
	for i := 0; i < phx.GetObjectCount(); i++ {
		if phx.GetObjectTag(i) == TAG_DOLLAR {
			pos = phx.GetObjectPosition(i)
			rot = phx.GetObjectRotation(i)
			var quat mat.v4 = mat.QuaternionFromAxisAngle(rot.x, rot.y, rot.z, rot.w)
			var rotation []f32 = mat.MatrixCreateRotationFromQuaternion(tmpMatrix, quat.x, quat.y, quat.z, quat.w)
			var right mat.v3 = mat.v3_transform_vector(mat.v3_(size.x, 0.0, 0.0), rotation)
			var top mat.v3 = mat.v3_transform_vector(mat.v3_(0.0, size.y, 0.0), rotation)
			var back mat.v3 = mat.v3_transform_vector(mat.v3_(0.0, 0.0, size.z), rotation)
			gfx.MeshAppendPlane(dollarMesh, false, true, pos, right, top, back, 2, 2, mat.v4_(0.5, 0.5, 1.0, 1.0), mat.v4_(1.0, 1.0, 1.0, 1.0))
		}
	}
	gfx.MeshEnd(dollarMesh)
	gfx.DepthState(true, gfx.LESS, true)

	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_COLOR_UNI, true)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_COLOR_VTX, false)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_COLOR_MAP, true)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_PBR_UNI, true)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_PBR_MAP, false)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_EMISSIVE_UNI, false)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_EMISSIVE_MAP, false)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_NORMAL_VTX, false)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_NORMAL_MAP, false)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_TANGENT_VTX, false)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_OCCLUSION_MAP, false)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_SKIN, false)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_DEBUG_A, true)

	var effect gfx.EffectId = gfx.TemplateInstance(gfx.g_tfxPbr)

	gfx.EffectUse(effect)
	gfx.EffectAssignTexture(effect, gfx.SAMPLER_COLOR_0, dollar, gfx.g_linear0Wrap)
	gfx.EffectAssignTexture(effect, gfx.SAMPLER_ENV_SPECULAR, skySpecular, gfx.g_linearWrap)
	gfx.EffectAssignTexture(effect, gfx.SAMPLER_ENV_DIFFUSE, skyDiffuse, gfx.g_linearWrap)
	gfx.EffectAssignTexture(effect, gfx.SAMPLER_BRDF, brdf, gfx.g_linear0Wrap)

	tmpColor[0] = 1.0
	tmpColor[1] = 1.0
	tmpColor[2] = 1.0
	tmpColor[3] = 1.0
	gfx.EffectAssignVector4(effect, gfx.UNIFORM_COLOR, tmpColor)

	tmpColor[0] = 0.0
	tmpColor[1] = 1.0
	tmpColor[2] = 0.0
	tmpColor[3] = 0.0
	gfx.EffectAssignVector4(effect, gfx.UNIFORM_METAL_ROUGH, tmpColor)

	//tmpColor[0] = 0.1
	//tmpColor[1] = 0.1
	//tmpColor[2] = 0.1
	//tmpColor[3] = 1.0
	//gfx.EffectAssignVector4(effect, gfx.UNIFORM_EMISSIVE, tmpColor)

	tmpColor[0] = cameraPosition.x
	tmpColor[1] = cameraPosition.y
	tmpColor[2] = cameraPosition.z
	tmpColor[3] = 1.0
	gfx.EffectAssignVector4(effect, gfx.UNIFORM_CAMERA_POSITION, tmpColor)

	gfx.EffectAssignMatrix4(effect, gfx.UNIFORM_WORLD, identity, false)
	gfx.EffectAssignMatrix4(effect, gfx.UNIFORM_VIEW, view, false)
	gfx.EffectAssignMatrix4(effect, gfx.UNIFORM_PROJECTION, projection, false)
	gfx.MeshSetCulling(dollarMesh, gfx.CW, gfx.NONE)
	gfx.MeshRender(dollarMesh)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func skycoinOnUpdate(controlIndex i32, controlAction i32) {
	if snd.VoiceState(voiceId) == snd.VOICE_STOPPED {
		snd.VoicePlay(voiceId)
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func onPlayButton(controlIndex i32, controlAction i32) {
	if controlAction == app.KEY_PRESS {
		gui.ScreenShow(gameScreen)
	} else if controlAction != app.KEY_RELEASE && controlAction != app.KEY_REPEAT {
		panicIfNot(false, "invalid action")
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func onExitButton(controlIndex i32, controlAction i32) {
	if controlAction == app.KEY_PRESS {
		gui.ScreenShow(exitScreen)
	} else if controlAction != app.KEY_RELEASE && controlAction != app.KEY_REPEAT {
		panicIfNot(false, "invalid action")
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func onExitDialogNo(controlIndex i32, controlAction i32) {
	if (controlAction == app.KEY_PRESS) {
	} else if (controlAction == app.KEY_RELEASE) {
		gui.ScreenHideModal(exitScreen)
	} else if (controlAction == app.KEY_REPEAT) {
	} else {
		panicIfNot(false, "invalid controlAction")
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func onExitDialogYes(controlIndex i32, controlAction i32) {
	if (controlAction == app.KEY_PRESS) {
	} else if (controlAction == app.KEY_RELEASE) {
		gui.ScreenHideModal(exitScreen)
		app.Exit()
	} else if (controlAction == app.KEY_REPEAT) {
	} else {
		panicIfNot(false, "invalid action")
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func loadModel(path str, filename str, s f32, r f32, v f32, options i32) (out gfx.ModelId) {
	printf("loading '%s/%s'\n", path, filename)
	out = gfx.ModelCreateFromFile(sprintf("%s/models/%s/", app.DataDir(), path), filename, options)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func animCreate(name str, options i32) (out Anim) {
	out.model = loadModel(name, "scene.gltf", playerScale, playerScale, playerScale, options)
	out.anim = gfx.ModelGetAnimation(out.model, 0)
}

func playerCreate(pattern str, spine str, torso str, shoulder str, hand str) (out Player) {
	out.idle = animCreate(sprintf("%s_idle", pattern), gfx.MODEL_GEOMETRY)
	out.jump = animCreate(sprintf("%s_jump", pattern), gfx.MODEL_ANIMATION)
	out.throw = animCreate(sprintf("%s_throw", pattern), gfx.MODEL_ANIMATION)
	out.forward = animCreate(sprintf("%s_forward", pattern), gfx.MODEL_ANIMATION)
	out.backward = animCreate(sprintf("%s_backward", pattern), gfx.MODEL_ANIMATION)
	out.left = animCreate(sprintf("%s_left", pattern), gfx.MODEL_ANIMATION)
	out.right = animCreate(sprintf("%s_right", pattern), gfx.MODEL_ANIMATION)

	var model gfx.ModelId = out.idle.model
	out.spine = gfx.ModelGetNodeByName(model, spine)
	out.torso = gfx.ModelGetNodeByName(model, torso)
	out.shoulder = gfx.ModelGetNodeByName(model, shoulder)
	out.hand = gfx.ModelGetNodeByName(model, hand)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func main()() {
	// init
	gam.Init("skylight", 1024, 768, 60, "")
	phx.Init(30U, -9.8 * 0.1)

	skyMesh = gfx.MeshLock(gfx.TRIANGLES, gfx.UNSIGNED_SHORT, 36, gfx.g_vertexLayout, 24);
	gfx.MeshBegin(skyMesh)
	gfx.MeshAppendBox(skyMesh, false, true,
		mat.v3_(0.0, 0.0, 0.0),
		mat.v3_(5000.0, 0.0, 0.0), mat.v3_(0.0, 5000.0, 0.0), mat.v3_(0.0, 0.0, 5000.0),
		mat.v4_(1.0, 1.0, 1.0, 1.0))
	gfx.MeshEnd(skyMesh)

	skyminerModel = loadModel("Skyminer_7_1/", "skyminer_low_test.gltf", 0.01, 0.01, 0.0, gfx.MODEL_GEOMETRY)
	//var playerScale f32 = 0.0000001

	players = append(players, playerCreate("synth", "mixamorig:Hips_00", "mixamorig:Spine_01", "mixamorig:RightShoulder_011", "mixamorig:RightHand_014"))
	players = append(players, playerCreate("vitalik", "mixamorig:Hips_00", "mixamorig:Spine_01", "mixamorig:RightShoulder_011", "mixamorig:RightHand_014"))
	currentPlayer = 0
	currentAnim = players[0].idle.anim
	runtimeAnim = currentAnim
	previousAnim = currentAnim

	tmpAnim0 = gfx.AnimationCreate()
	tmpAnim1 = gfx.AnimationCreate()
	tmpAnim2 = gfx.AnimationCreate()

	phxPlayer = phx.AddObject(phx.TYPE_ELLIPSE, TAG_PLAYER, phx.STATE_TRANSLATE | phx.STATE_DEBUG | phx.STATE_DEBUG_COLOR,
			mat.v3_(4.0 + f32.rand() * 20.0, 4.0 + f32.rand() * 2.0, -25.0 + f32.rand() * 20.0), mat.v3_(0.0, 0.0, 0.0), mat.v3_(0.0, 0.0, 0.0),
			mat.v3_(1.0, 0.0, 0.0), mat.v3_(0.0, 1.0, 0.0), mat.v3_(0.0, 0.0, 1.0),
			75.0 + f32.rand() * 50.0, 1.0, mat.v4_(0.0, 0.0, 1.0, 0.0), mat.v4_(1.0, 1.0, 1.0, 1.0))

	dollarMesh = gfx.MeshCreate(gfx.TRIANGLES, gfx.UNSIGNED_SHORT, 8192 * 3, gfx.g_vertexLayout, 8192 * 3)
	groundMesh = gfx.MeshLock(gfx.TRIANGLES, gfx.UNSIGNED_SHORT, 6 * groundWidth * groundHeight, gfx.g_vertexLayout, 6 * groundWidth * groundHeight)
	gfx.MeshBegin(groundMesh)
	gfx.MeshAppendPlane(groundMesh, false, true,
		mat.v3_(0.0, 0.0, 0.0),
		mat.v3_(groundRight, 0.0, 0.0),
		mat.v3_(0.0, 1.0, 0.0),
		mat.v3_(0.0, 0.0, groundBack),
		groundWidth, groundHeight,
		mat.v4_(0.0, 0.0, 10.0, 10.0),
		mat.v4_(1.0, 1.0, 1.0, 1.0))
	gfx.MeshEnd(groundMesh)
	phxGround0 = phx.AddObject(phx.TYPE_PLANE, TAG_GROUND, phx.STATE_ACTIVE | phx.STATE_DEBUG | phx.STATE_DEBUG_COLOR | phx.STATE_DEBUG_WIRE,
		mat.v3_(0.0, worldPosY, 0.0), mat.v3_(0.0, 0.0, 0.0), mat.v3_(0.0, 0.0, 0.0),
		mat.v3_(groundRight, 0.0, 0.0), mat.v3_(0.0, 1.0, 0.0), mat.v3_(0.0, 0.0, groundBack),
		0.0, 1.0, mat.v4_(0.0, 1.0, 0.0, 0.0), mat.v4_(1.0, 1.0, 1.0, 1.0))
	phx.SetObjectRotation(phxGround0, mat.v4_(0.0, 0.0, 1.0, 0.2))
	phxGround1 = phx.AddObject(phx.TYPE_PLANE, TAG_GROUND, phx.STATE_ACTIVE | phx.STATE_DEBUG | phx.STATE_DEBUG_COLOR | phx.STATE_DEBUG_WIRE,
		mat.v3_(-100.0, 2.0 * worldPosY, 0.0), mat.v3_(0.0, 0.0, 0.0), mat.v3_(0.0, 0.0, 0.0),
		mat.v3_(groundRight, 0.0, 0.0), mat.v3_(0.0, 1.0, 0.0), mat.v3_(0.0, 0.0, groundBack),
		0.0, 1.0, mat.v4_(0.0, 1.0, 0.0, 0.0), mat.v4_(1.0, 1.0, 1.0, 1.0))

	dollar = gfx.TextureCreate(sprintf("%s/textures/skynote.png", app.DataDir()),
		gfx.FORMAT_R8_G8_B8_A8, 0, 0, -1, false)

	texture = gfx.TextureCreate(sprintf("%s/textures/Skycoin-Cloud-BW-Vertical-on_black@2x.png", app.DataDir()),
		gfx.FORMAT_R8_G8_B8_A8, 0, 0, -1, false)
	skySpecular = gfx.TextureCreateCube(sprintf("%s/textures/skybox/", app.DataDir()), ".jpg",
		gfx.FORMAT_R8_G8_B8_A8, 0, 0, -1, false)
	skyDiffuse= gfx.TextureCreateCube(sprintf("%s/textures/irradiance/", app.DataDir()), ".png",
		gfx.FORMAT_R8_G8_B8_A8, 0, 0, -1, false)
	brdf = gfx.TextureCreate(sprintf("%s/textures/brdfLUT.png", app.DataDir()),
		gfx.FORMAT_R8_G8_B8_A8, 0, 0, 0, false)

	camera = gam.CameraCreate()
	gam.CameraSetProjection(camera, 0.1, 10000.0, 0.5, gfx.gfx_viewportSize.x, gfx.gfx_viewportSize.y, true)
	gam.CameraSetPosition(camera, mat.v3_(0.0, worldPosY + 1.0, 0.0), true)
	gam.CameraSetYawPitch(camera, 0.0, 0.0, true)

	tmpColor = resize(tmpColor, 4)
	identity = mat.MatrixIdentity(identity)
	var audioId snd.AudioId = snd.AudioCreate(sprintf("%s/audios/skycoin_baby.wav", app.DataDir()))
	voiceId = snd.VoiceCreate(audioId)

   	// exitScreen
	exitScreen  = gui.ScreenCreate("exitScreen")
	gui.ControlSetSkin(exitScreen.base, gui.g_modalSkin)
	gui.ControlSetDock(exitScreen.base, gui.DOCK_FILL)
	gui.ScreenSetDuration(exitScreen, -2.0D)
	gui.ScreenSetModal(exitScreen, true)

	{
		var exitWindow gui.WindowId = gui.WindowCreate("exitWindow")
		gui.ControlAddChild(exitScreen.base, exitWindow.base)
		gui.ControlSetSkin(exitWindow.base, gui.g_windowSkin)
		gui.ControlSetAutosize(exitWindow.base, gui.AUTOSIZE)
		gui.ControlSetAlign(exitWindow.base, gui.ALIGN_CENTER)
		gui.WindowSetCaption(exitWindow, "cxfx")
		gui.WindowAddButton(exitWindow, "no", "No", "main", "onExitDialogNo")
		gui.WindowAddButton(exitWindow, "yes", "Yes", "main", "onExitDialogYes")

		{
			var exitLabel gui.LabelId = gui.LabelCreate("exitLabel")
			gui.WindowSetContainee(exitWindow, exitLabel.base)
			gui.ControlSetDock(exitLabel.base, gui.DOCK_FILL)
			gui.ControlSetAutosize(exitLabel.base, gui.AUTOSIZE)
			gui.LabelSetFont(exitLabel, gui.g_regularFont)
			gui.LabelSetText(exitLabel, "Do you want to quit ?")
			gui.LabelSetSize(exitLabel, gui.g_fontSizeText)
			gui.LabelSetColor(exitLabel, gui.g_white)
			gui.LabelSetAlign(exitLabel, gui.ALIGN_CENTER)
		}
	}
	// mainScreen
	var mainScreen gui.ScreenId = gui.ScreenCreate("mainScreen")
	gui.ControlSetSkin(mainScreen.base, gui.g_blackSkin)
	gui.ControlSetDock(mainScreen.base, gui.DOCK_FILL)
	gui.ControlSetPadding(mainScreen.base, mat.v4_(200.0, 150.0, 200.0, 150.0))
	gui.ScreenSetDuration(mainScreen, -1.0D)
	gui.ScreenSetOnExit(mainScreen, exitScreen)
	{
		var playButton gui.LabelId = gui.LabelCreate("playButton")
		gui.ControlAddChild(mainScreen.base, playButton.base)
		gui.ControlSetSkin(playButton.base, gui.g_blueSkin)
		gui.ControlSetDock(playButton.base, gui.DOCK_TOP)
		gui.ControlSetFocusable(playButton.base, 1)
		gui.ControlSetPadding(playButton.base, mat.v4_(5.0, 5.0, 5.0, 5.0))
		gui.ControlSetAutosize(playButton.base, gui.AUTOSIZE_Y)
		gui.LabelSetFont(playButton, gui.g_boldFont)
		gui.LabelSetText(playButton, "Play")
		gui.LabelSetOnState(playButton, "main", "onPlayButton")
		gui.LabelSetSize(playButton, gui.g_fontSizeButton)
		gui.LabelSetColor(playButton, gui.g_white)
		gui.LabelSetAlign(playButton, gui.ALIGN_CENTER)

		var exitButton gui.LabelId = gui.LabelCreate("exitButton")
		gui.ControlAddChild(mainScreen.base, exitButton.base)
		gui.ControlSetSkin(exitButton.base, gui.g_blueSkin)
		gui.ControlSetDock(exitButton.base, gui.DOCK_TOP)
		gui.ControlSetFocusable(exitButton.base, 1)
		gui.ControlSetPadding(exitButton.base, mat.v4_(5.0, 5.0, 5.0, 5.0))
		gui.ControlSetAutosize(exitButton.base, gui.AUTOSIZE_Y)
		gui.LabelSetFont(exitButton, gui.g_boldFont)
		gui.LabelSetText(exitButton, "Exit")
		gui.LabelSetOnState(exitButton, "main", "onExitButton")
		gui.LabelSetSize(exitButton, gui.g_fontSizeButton)
		gui.LabelSetColor(exitButton, gui.g_white)
		gui.LabelSetAlign(exitButton, gui.ALIGN_CENTER)
	}

	// gameScreen
	gameScreen = gui.ScreenCreate("gameScreen")
	gui.ControlSetDock(gameScreen.base, gui.DOCK_FILL)
	gui.ScreenSetDuration(gameScreen, -1.0D)
	gui.ScreenSetOnExit(gameScreen, mainScreen)
	gui.ScreenSetOnEvent(gameScreen, "main", "gameOnEvent")
	gui.ScreenSetOnUpdate(gameScreen, "main", "gameOnUpdate")
	gui.ScreenSetOnRender(gameScreen, "main", "gameOnRender")

	// titleScreen
	var titleScreen gui.ScreenId = gui.ScreenCreate("titleScreen")
	gui.ControlSetSkin(titleScreen.base, gui.g_blackSkin)
	gui.ControlSetDock(titleScreen.base, gui.DOCK_FILL)
	gui.ScreenSetDuration(titleScreen, 2.0D)
	gui.ScreenSetOnNext(titleScreen, mainScreen)
	{
		var label gui.LabelId= gui.LabelCreate("titleLabel")
		gui.ControlAddChild(titleScreen.base, label.base)
		gui.ControlSetBounds(label.base, mat.v4_(0.0, 0.0, gfx.gfx_width, gfx.gfx_height))
		gui.ControlSetAlign(label.base, gui.ALIGN_CENTER)
		gui.LabelSetFont(label, gui.g_boldFont)
		gui.LabelSetText(label, app.Name())
		gui.LabelSetSize(label, gui.g_fontSizeTitle)
		gui.LabelSetAlign(label, gui.ALIGN_CENTER)
		gui.LabelSetColor(label, gui.g_gold)
	}

	// skycoinScreen
	var skycoinScreen gui.ScreenId = gui.ScreenCreate("skycoinSceen")
	gui.ControlSetSkin(skycoinScreen.base, gui.g_blackSkin)
	gui.ControlSetDock(skycoinScreen.base, gui.DOCK_FILL)
	gui.ScreenSetDuration(skycoinScreen, 2.0D)
	gui.ScreenSetOnUpdate(skycoinScreen, "main", "skycoinOnUpdate")
	gui.ScreenSetOnNext(skycoinScreen, titleScreen)
	{
		var picture PictureId = gui.PictureCreate("skycoinPicture")
		gui.ControlAddChild(skycoinScreen.base, picture.base)
		gui.ControlSetBounds(picture.base, mat.v4_(0.0, 0.0, gfx.gfx_width / 2.0, gfx.gfx_height / 2.0))
		gui.ControlSetAlign(picture.base, gui.ALIGN_CENTER)
		gui.ControlSetAutoscale(picture.base, gui.AUTOSCALE)
		gui.PictureSetAlign(picture, gui.ALIGN_CENTER)
		gui.PictureSetAnimation(picture, gui.g_skycoinAnim)
	}

	// bootScreen
	var bootScreen gui.ScreenId = gui.ScreenCreate("bootScreen")
	gui.ControlSetSkin(bootScreen.base, gui.g_bootSkin)
	gui.ControlSetDock(bootScreen.base, gui.DOCK_FILL)
	gui.ScreenSetDuration(bootScreen, 2.0D)
	gui.ScreenSetOnNext(bootScreen, skycoinScreen)

	// run
	gui.ScreenShow(bootScreen)
	gam.Run(2U)

	// destroy
	gfx.MeshUnlock(skyMesh)
	gfx.MeshUnlock(groundMesh)
	gam.Destroy()
}

