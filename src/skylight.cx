package main

import "app"
import "fps"
import "gam"
import "gfx"
import "gui"
import "mat"
import "snd"
import "phx"

// TODO : can't navigate with keyboard at startup
// TODO : dialog disapear if exit button is pushed with keyboard

// Globals ...
var gameScreen gui.ScreenId
var exitScreen gui.ScreenId

var skyminerModel gfx.ModelId = gfx.ModelInvalid()
var skyminerScale f32 = 0.005

var playerModel gfx.ModelId = gfx.ModelInvalid()
var playerScale f32 = 0.1

var groundMesh gfx.MeshId = gfx.InvalidMesh()
var texture gfx.TextureId = gfx.InvalidTexture()
var dollar gfx.TextureId = gfx.InvalidTexture()

var dollarMesh gfx.MeshId = gfx.InvalidMesh()

var skyMesh gfx.MeshId = gfx.InvalidMesh()
var skyDiffuse gfx.TextureId = gfx.InvalidTexture()
var skySpecular gfx.TextureId = gfx.InvalidTexture()
var brdf gfx.TextureId = gfx.InvalidTexture()

var world [] f32 = mat.MatrixAlloc()
var identity [] f32 = mat.MatrixAlloc()
var tmpMatrix []f32 = mat.MatrixAlloc()
var tmpColor []f32

var camera gam.CameraId

var worldPosY f32 = -10.0

var worldSizeX f32 = 2000.0
var worldSizeZ f32 = 2000.0

var worldCellX i32 = 64
var worldCellZ i32 = 64

var phxPlayer i32
var phxGround0 i32
var phxGround1 i32

var groundScale f32 = 20.0
var groundRight f32 = worldSizeX / groundScale
var groundBack f32 = worldSizeZ / groundScale
var groundWidth i32 = 16
var groundHeight i32 = 16

var voiceId snd.VoiceId

var TAG_GROUND i32 = 1
var TAG_PLAYER i32 = 2
var TAG_MINER i32 = 3
var TAG_DOLLAR i32 = 4

var CAMERA_FREE i32 = 0
var CAMERA_TPS i32 = 1
var CAMERA_FPS i32 = 2
var CAMERA_COUNT i32 = 3
var currentCamera i32 = CAMERA_FPS

var fireWeapon i32 = 0

var WEAPON_SKYNOTE i32 = 0
var WEAPON_SKYMINER i32 = 1
var WEAPON_COUNT i32 = 2

var currentWeapon i32 = WEAPON_SKYNOTE

var xdir f32
var zdir f32

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func gameOnEvent(controlIndex i32, controlAction i32) {
	var key i32 = gui.CurrentEvent.keyboard.key
	var action i32 = gui.CurrentEvent.keyboard.action
	var mods i32 = gui.CurrentEvent.keyboard.mods

	if mods == app.MOD_CTRL {
	} else if mods == app.MOD_SHIFT {
		if action == app.KEY_PRESS {
			if key == app.KEYCODE_LEFT {
				if action == app.KEY_PRESS {
					currentCamera = currentCamera - 1
					if currentCamera < 0 {
						currentCamera = CAMERA_COUNT - 1
					}
				}
			} else if key == app.KEYCODE_RIGHT {
				if action == app.KEY_PRESS {
					currentCamera = currentCamera + 1
					if currentCamera >= CAMERA_COUNT {
						currentCamera = 0
					}
				}
			}
		}
	} else if mods == app.MOD_NONE {
   		if key == app.KEYCODE_LEFT || key == app.KEYCODE_A {
			if action == app.KEY_PRESS {
				zdir = -1.0
			} else if action == app.KEY_RELEASE {
				zdir = 0.0
			}
		} else if key == app.KEYCODE_RIGHT || key == app.KEYCODE_D {
			if action == app.KEY_PRESS {
				zdir = 1.0
			} else if action == app.KEY_RELEASE {
				zdir = 0.0
			}
		} else if key == app.KEYCODE_UP || key == app.KEYCODE_W {
			if action == app.KEY_PRESS {
				xdir = -1.0
			} else if action == app.KEY_RELEASE {
				xdir = 0.0
			}
		} else if key == app.KEYCODE_DOWN || key == app.KEYCODE_S {
			if action == app.KEY_PRESS {
				xdir = 1.0
			} else if action == app.KEY_RELEASE {
				xdir = 0.0
			}
		} else if key == app.KEYCODE_SPACE {
			if action == app.KEY_PRESS {
				if currentWeapon == WEAPON_SKYNOTE {
					fireWeapon = 1
				} else if currentWeapon == WEAPON_SKYMINER {
					fireWeapon = 1
				}
			} else if action == app.KEY_RELEASE {
				fireWeapon = 0
			}
		} else if key == app.KEYCODE_1 {
			if action == app.KEY_PRESS {
				currentWeapon = WEAPON_SKYMINER
			}
		} else if key == app.KEYCODE_2 {
			if action == app.KEY_PRESS {
				currentWeapon = WEAPON_SKYNOTE
			}
		}
	}

	var mouseAction i32 = gui.CurrentEvent.mouse.action
	var mouseButton i32 = gui.CurrentEvent.mouse.button

	if mouseAction == app.MOUSE_PRESS && mouseButton == app.BUTTON_LEFT {
	}

	if currentCamera == CAMERA_FREE {
		gam.FreeCameraProcess(camera, &gui.CurrentEvent)
	} else if currentCamera == CAMERA_FPS {
		gam.FpsCameraProcess(camera, &gui.CurrentEvent)
	} else if currentCamera == CAMERA_TPS {
		gam.TpsCameraProcess(camera, &gui.CurrentEvent)
	}
}

func fireSkyminer(position mat.v3, direction mat.v3) {
	var objType i32 = phx.TYPE_BOX
	var objTag i32 = TAG_MINER

	var state i32 = phx.STATE_TRANSLATE | phx.STATE_ROTATE

	var axis mat.v3 = mat.v3_normalize(mat.v3_rand())

	var mass f32 = 5.0
	var force f32 = 10000.0

	var min mat.v3 = gfx.ModelGetMin(skyminerModel)
	var max mat.v3 = gfx.ModelGetMax(skyminerModel)
	var radius f32 = skyminerScale * 0.51

	var right mat.v3 = mat.v3_(radius * (max.x - min.x), 0.0, 0.0)
	var top mat.v3 = mat.v3_(0.0, radius * (max.y - min.y), 0.0)
	var back mat.v3 = mat.v3_(0.0, 0.0, radius * (max.z - min.z))

	var acceleration mat.v3 = mat.v3_mulf(direction, force / mass)

	var miner i32 = phx.AddObject(objType, objTag, state, position, mat.v3_(0.0, 0.0, 0.0), acceleration,
		right, top, back, mass, mat.v4_(axis.x, axis.y, axis.z, f32.rand() * 10.0))
}

func fireSkynotes(position mat.v3, direction mat.v3) {

	var objType i32 = phx.TYPE_PLANE
	var objTag i32 = TAG_DOLLAR

	var state i32 = phx.STATE_TRANSLATE | phx.STATE_ROTATE

	var mass f32 = 0.01

	var skynoteCount i32 = i32.rand(1, 10)
	for i := 0; i < skynoteCount; i++ {
		var at mat.v3 = mat.v3_normalize(mat.v3_add(direction, mat.v3_(f32.rand() * 0.2 - 0.1, f32.rand() * 0.2 - 0.1, f32.rand() * 0.2 - 0.1)))
		var axis mat.v3 = mat.v3_normalize(mat.v3_rand())

		var force f32 = 10.0 + f32.rand() * 1.0
		var right mat.v3 = mat.v3_(0.5 + f32.rand() * 0.5, 0.0, 0.0)
		var top mat.v3 = mat.v3_(0.0, 0.5 + f32.rand() * 0.5, 0.0)
		var back mat.v3 = mat.v3_(0.0, 0.0, 0.5 + f32.rand() * 0.5)

		var acceleration mat.v3 = mat.v3_mulf(at, force / mass)

		var miner i32 = phx.AddObject(objType, objTag, state, position, mat.v3_(0.0, 0.0, 0.0), acceleration,
			right, top, back, mass, mat.v4_(axis.x, axis.y, axis.z, f32.rand() * 10.0))
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var firstUpdate bool = false
func gameOnUpdate(controlIndex i32, controlAction i32) {
	// >> HACK : start cx profiling
	if firstUpdate == false {
		firstUpdate = true
		debugI32(0)
	}
	// << HACK : start cx profiling

	var playerAt mat.v3 = phx.GetObjectAt(phxPlayer)
	var playerOffset mat.v3 = mat.v3_add(mat.v3_mulf(playerAt, 0.4), mat.v3_(0.0, 18.0, 0.0))
 
	var cameraAt mat.v3 = gam.CameraGetAt(camera)
	var cameraPos mat.v3 = gam.CameraGetPosition(camera)

	var weaponAt mat.v3
	var weaponPos mat.v3
	if currentCamera == CAMERA_FREE {
		weaponAt = cameraAt
		weaponPos = cameraPos
	} else if currentCamera == CAMERA_TPS {
		weaponAt = mat.v3_normalize(mat.v3_sub(mat.v3_add(playerOffset, phx.GetObjectPosition(phxPlayer)), gam.CameraGetPosition(camera)))
		weaponPos = cameraPos
	} else if currentCamera == CAMERA_FPS {
		weaponAt = cameraAt
		weaponPos = cameraPos
	}

	if fireWeapon > 0 {
		if currentWeapon == WEAPON_SKYMINER {
			fireSkyminer(weaponPos, weaponAt)
			fireWeapon = 0
		} else if currentWeapon == WEAPON_SKYNOTE {
			fireSkynotes(weaponPos, weaponAt)
		}
	}


	var dts f64 = fps.DeltaSecond()
	var dt f32 = f64.f32(dts)


	var acceleration mat.v3
	var at mat.v3
	var right mat.v3


	if currentCamera == CAMERA_FREE {
	} else if currentCamera == CAMERA_FPS {
		if xdir != 0.0 {
			at = playerAt
		}
		if zdir != 0.0 {
			right = phx.GetObjectRight(phxPlayer)
		}
	} else if currentCamera == CAMERA_TPS {
		if xdir != 0.0 {
			at = gam.CameraGetAt(camera)
		}
		if zdir != 0.0 {
			right = gam.CameraGetRight(camera)
		}
	}

	acceleration = mat.v3_add(acceleration, mat.v3_mulf(at, dt * 2000.0 * xdir))
	acceleration = mat.v3_add(acceleration, mat.v3_mulf(right, dt * 2000.0 * zdir))
	acceleration.y = 0.0


	phx.SetObjectAcceleration(phxPlayer, acceleration)
	var playerVelocity mat.v3 = phx.GetObjectVelocity(phxPlayer)
	var playerVelocityLength f32 = mat.v3_length(playerVelocity)
	var maxVelocity f32 = 200.0
	if playerVelocityLength > maxVelocity {
		playerVelocity = mat.v3_mulf(playerVelocity, maxVelocity / playerVelocityLength)
	}
	phx.SetObjectVelocity(phxPlayer, playerVelocity)
	phx.Update(fps.DeltaNano())



	var playerPosition mat.v3 = mat.v3_add(playerOffset, phx.GetObjectPosition(phxPlayer))
	if currentCamera == CAMERA_FREE {
		gam.FreeCameraUpdate(camera, dts)
	} else if currentCamera == CAMERA_FPS {
		gam.FpsCameraUpdate(camera, dts, playerPosition)
	} else if currentCamera == CAMERA_TPS {
		gam.TpsCameraUpdate(camera, dts, playerPosition, 30.0)
	}


	var i i32
	for i = 0; i < phx.GetObjectCount(); i++ {
		var objTag i32 = phx.GetObjectTag(i)
		if objTag == TAG_MINER || objTag == TAG_DOLLAR {
			var position mat.v3 = phx.GetObjectPosition(i)
			if position.y < worldPosY * 2.0 {
				phx.RemoveObject(i)
				i = i - 1
			}
		}
	}
	gfx.ModelUpdate(skyminerModel, dt, true)
	gfx.ModelUpdate(playerModel, dt, true)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func gameOnRender(controlIndex i32, controlAction i32) {
	var view []f32 = gam.CameraGetView(camera)
	var projection []f32 = gam.CameraGetProjection(camera)
	var cameraPosition mat.v3 = gam.CameraGetPosition(camera)

	gfx.DisableBlending()
	gfx.DepthState(true, gfx.LESS, true)
	gfx.Clear(gfx.COLOR_BUFFER_BIT | gfx.DEPTH_BUFFER_BIT, mat.v4_(0.3, 0.5, 0.6, 1.0), 1.0D, 0)

	//sky
	gfx.EffectUse(gfx.g_fxSky)
	gfx.EffectAssignTexture(gfx.g_fxSky, gfx.SAMPLER_ENV_DIFFUSE, skySpecular, gfx.g_linearWrap)
	gfx.EffectAssignMatrix4(gfx.g_fxSky, gfx.UNIFORM_WORLD, identity, false)
	gfx.EffectAssignMatrix4(gfx.g_fxSky, gfx.UNIFORM_VIEW, view, false)
	gfx.EffectAssignMatrix4(gfx.g_fxSky, gfx.UNIFORM_PROJECTION, projection, false)
	gfx.MeshRender(skyMesh)

	// ground
	gfx.EffectUse(gfx.g_fxTexture3D)
	gfx.EffectAssignTexture(gfx.g_fxTexture3D, gfx.SAMPLER_COLOR_0, texture, gfx.g_linearWrap)
	gfx.EffectAssignMatrix4(gfx.g_fxTexture3D, gfx.UNIFORM_VIEW, view, false)
	gfx.EffectAssignMatrix4(gfx.g_fxTexture3D, gfx.UNIFORM_PROJECTION, projection, false)
	var pos mat.v3 = phx.GetObjectPosition(phxGround0)
	var rot mat.v4 = phx.GetObjectRotation(phxGround0)
	var quat mat.v4 = mat.QuaternionFromAxisAngle(rot.x, rot.y, rot.z, rot.w)
	world = mat.MatrixCreate2(world, 1.0, 1.0, 1.0, quat.x, quat.y, quat.z, quat.w, pos.x, pos.y, pos.z)
	gfx.EffectAssignMatrix4(gfx.g_fxTexture3D, gfx.UNIFORM_WORLD, world, false)
	gfx.MeshRender(groundMesh)
	pos = phx.GetObjectPosition(phxGround1)
	rot = phx.GetObjectRotation(phxGround1)
	quat = mat.QuaternionFromAxisAngle(rot.x, rot.y, rot.z, rot.w)
	world = mat.MatrixCreate2(world, 1.0, 1.0, 1.0, quat.x, quat.y, quat.z, quat.w, pos.x, pos.y, pos.z)
	gfx.EffectAssignMatrix4(gfx.g_fxTexture3D, gfx.UNIFORM_WORLD, world, false)
	gfx.MeshRender(groundMesh)

	// physics
	phx.Render(identity, view, projection)

	// player
	gfx.ModelSetView(playerModel, view)
	gfx.ModelSetProjection(playerModel, projection)
	gfx.ModelSetEnvironmentSpecular(playerModel, skySpecular)
	gfx.ModelSetEnvironmentDiffuse(playerModel, skyDiffuse)
	gfx.ModelSetBRDF(playerModel, brdf)
	gfx.ModelSetCameraPosition(playerModel, cameraPosition)
	pos = phx.GetObjectPosition(phxPlayer)
	rot = phx.GetObjectRotation(phxPlayer)
	quat = mat.QuaternionFromAxisAngle(rot.x, rot.y, rot.z, rot.w)
	world = mat.MatrixCreate2(world, playerScale, playerScale, playerScale, quat.x, quat.y, quat.z, quat.w, pos.x, pos.y, pos.z)
	gfx.ModelSetWorld(playerModel, world)
	gfx.ModelRender(playerModel)

	// skyminers
	gfx.ModelSetView(skyminerModel, view)
	gfx.ModelSetProjection(skyminerModel, projection)
	gfx.ModelSetEnvironmentSpecular(skyminerModel, skySpecular)
	gfx.ModelSetEnvironmentDiffuse(skyminerModel, skyDiffuse)
	gfx.ModelSetBRDF(skyminerModel, brdf)
	gfx.ModelSetCameraPosition(skyminerModel, cameraPosition)
	for i := 0; i < phx.GetObjectCount(); i++ {
		if phx.GetObjectTag(i) == TAG_MINER {
			pos = phx.GetObjectPosition(i)
			rot = phx.GetObjectRotation(i)
			quat = mat.QuaternionFromAxisAngle(rot.x, rot.y, rot.z, rot.w)
			world = mat.MatrixCreate2(world, skyminerScale, skyminerScale, skyminerScale, quat.x, quat.y, quat.z, quat.w, pos.x, pos.y, pos.z)
			gfx.ModelSetWorld(skyminerModel, world)
			gfx.ModelRender(skyminerModel)
		}
	}

	// skynotes
	var size mat.v3 = mat.v3_mulf(mat.v3_(1.0, 1.0, 0.5), 0.75)
	gfx.MeshBegin(dollarMesh)
	for i := 0; i < phx.GetObjectCount(); i++ {
		if phx.GetObjectTag(i) == TAG_DOLLAR {
			pos = phx.GetObjectPosition(i)
			rot = phx.GetObjectRotation(i)
			var quat mat.v4 = mat.QuaternionFromAxisAngle(rot.x, rot.y, rot.z, rot.w)
			var rotation []f32 = mat.MatrixCreateRotationFromQuaternion(tmpMatrix, quat.x, quat.y, quat.z, quat.w)
			var right mat.v3 = mat.v3_transform_vector(mat.v3_(size.x, 0.0, 0.0), rotation)
			var top mat.v3 = mat.v3_transform_vector(mat.v3_(0.0, size.y, 0.0), rotation)
			var back mat.v3 = mat.v3_transform_vector(mat.v3_(0.0, 0.0, size.z), rotation)
			gfx.MeshAppendPlane(dollarMesh, false, true, pos, right, top, back, 2, 2, mat.v4_(0.5, 0.5, 1.0, 1.0), mat.v4_(1.0, 1.0, 1.0, 1.0))
		}
	}
	gfx.MeshEnd(dollarMesh)
	gfx.DepthState(true, gfx.LESS, true)

	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_COLOR_UNI, true)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_COLOR_VTX, false)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_COLOR_MAP, true)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_PBR_UNI, true)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_PBR_MAP, false)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_EMISSIVE_UNI, false)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_EMISSIVE_MAP, false)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_NORMAL_VTX, false)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_NORMAL_MAP, false)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_TANGENT_VTX, false)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_OCCLUSION_MAP, false)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_SKIN, false)
	gfx.TemplateSetKey(gfx.g_tfxPbr, gfx.USE_DEBUG_A, true)

	var effect gfx.EffectId = gfx.TemplateInstance(gfx.g_tfxPbr)

	gfx.EffectUse(effect)
	gfx.EffectAssignTexture(effect, gfx.SAMPLER_COLOR_0, dollar, gfx.g_linear0Wrap)
	gfx.EffectAssignTexture(effect, gfx.SAMPLER_ENV_SPECULAR, skySpecular, gfx.g_linearWrap)
	gfx.EffectAssignTexture(effect, gfx.SAMPLER_ENV_DIFFUSE, skyDiffuse, gfx.g_linearWrap)
	gfx.EffectAssignTexture(effect, gfx.SAMPLER_BRDF, brdf, gfx.g_linear0Wrap)

	tmpColor[0] = 1.0
	tmpColor[1] = 1.0
	tmpColor[2] = 1.0
	tmpColor[3] = 1.0
	gfx.EffectAssignVector4(effect, gfx.UNIFORM_COLOR, tmpColor)

	tmpColor[0] = 0.0
	tmpColor[1] = 1.0
	tmpColor[2] = 0.0
	tmpColor[3] = 0.0
	gfx.EffectAssignVector4(effect, gfx.UNIFORM_METAL_ROUGH, tmpColor)

	//tmpColor[0] = 0.1
	//tmpColor[1] = 0.1
	//tmpColor[2] = 0.1
	//tmpColor[3] = 1.0
	//gfx.EffectAssignVector4(effect, gfx.UNIFORM_EMISSIVE, tmpColor)

	tmpColor[0] = cameraPosition.x
	tmpColor[1] = cameraPosition.y
	tmpColor[2] = cameraPosition.z
	tmpColor[3] = 1.0
	gfx.EffectAssignVector4(effect, gfx.UNIFORM_CAMERA_POSITION, tmpColor)

	gfx.EffectAssignMatrix4(effect, gfx.UNIFORM_WORLD, identity, false)
	gfx.EffectAssignMatrix4(effect, gfx.UNIFORM_VIEW, view, false)
	gfx.EffectAssignMatrix4(effect, gfx.UNIFORM_PROJECTION, projection, false)
	gfx.MeshSetCulling(dollarMesh, gfx.CW, gfx.NONE)
	gfx.MeshRender(dollarMesh)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func skycoinOnUpdate(controlIndex i32, controlAction i32) {
	if snd.VoiceState(voiceId) == snd.VOICE_STOPPED {
		snd.VoicePlay(voiceId)
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func onPlayButton(controlIndex i32, controlAction i32) {
	if controlAction == app.KEY_PRESS {
		gui.ScreenShow(gameScreen)
	} else if controlAction != app.KEY_RELEASE && controlAction != app.KEY_REPEAT {
		panicIfNot(false, "invalid action")
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func onExitButton(controlIndex i32, controlAction i32) {
	if controlAction == app.KEY_PRESS {
		gui.ScreenShow(exitScreen)
	} else if controlAction != app.KEY_RELEASE && controlAction != app.KEY_REPEAT {
		panicIfNot(false, "invalid action")
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func onExitDialogNo(controlIndex i32, controlAction i32) {
	if (controlAction == app.KEY_PRESS) {
	} else if (controlAction == app.KEY_RELEASE) {
		gui.ScreenHideModal(exitScreen)
	} else if (controlAction == app.KEY_REPEAT) {
	} else {
		panicIfNot(false, "invalid controlAction")
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func onExitDialogYes(controlIndex i32, controlAction i32) {
	if (controlAction == app.KEY_PRESS) {
	} else if (controlAction == app.KEY_RELEASE) {
		gui.ScreenHideModal(exitScreen)
		app.Exit()
	} else if (controlAction == app.KEY_REPEAT) {
	} else {
		panicIfNot(false, "invalid action")
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func loadModel(path str, filename str, s f32, r f32, v f32) (out gfx.ModelId) {
	out = gfx.ModelCreateFromFile(sprintf("%s/models/%s/", app.DataDir(), path), filename)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func main()() {
	// init
	gam.Init("skylight", 1024, 768, 60, "")
	phx.Init(30U, -9.8)

	skyMesh = gfx.MeshLock(gfx.TRIANGLES, gfx.UNSIGNED_SHORT, 36, gfx.g_vertexLayout, 24);
	gfx.MeshBegin(skyMesh)
	gfx.MeshAppendBox(skyMesh, false, true,
		mat.v3_(0.0, 0.0, 0.0),
		mat.v3_(5000.0, 0.0, 0.0), mat.v3_(0.0, 5000.0, 0.0), mat.v3_(0.0, 0.0, 5000.0),
		mat.v4_(1.0, 1.0, 1.0, 1.0))
	gfx.MeshEnd(skyMesh)

	skyminerModel = loadModel("Skyminer_7_1/", "skyminer_low_test.gltf", 0.01, 0.01, 0.0)
	//playerModel = loadModel("synth_2_0", "scene.gltf", 1.0, 1.0, 1.0)  
	var playerScale f32 = 0.0000001
	playerModel = loadModel("synth_test_idle", "scene.gltf", playerScale, playerScale, playerScale)
	//playerModel = loadModel("synth_test_run", "scene.gltf", playerScale, playerScale, playerScale)

	phxPlayer = phx.AddObject(phx.TYPE_ELLIPSE, TAG_PLAYER, phx.STATE_TRANSLATE | phx.STATE_DEBUG | phx.STATE_DEBUG_COLOR,
			mat.v3_(4.0 + f32.rand() * 20.0, 4.0 + f32.rand() * 2.0, -25.0 + f32.rand() * 20.0), mat.v3_(0.0, 0.0, 0.0), mat.v3_(0.0, 0.0, 0.0),
			mat.v3_(1.0, 0.0, 0.0), mat.v3_(0.0, 1.0, 0.0), mat.v3_(0.0, 0.0, 1.0),
			75.0 + f32.rand() * 50.0, mat.v4_(0.0, 0.0, 1.0, 0.0))

	dollarMesh = gfx.MeshCreate(gfx.TRIANGLES, gfx.UNSIGNED_SHORT, 8192 * 3, gfx.g_vertexLayout, 8192 * 3)
	groundMesh = gfx.MeshLock(gfx.TRIANGLES, gfx.UNSIGNED_SHORT, 6 * groundWidth * groundHeight, gfx.g_vertexLayout, 6 * groundWidth * groundHeight)
	gfx.MeshBegin(groundMesh)
	gfx.MeshAppendPlane(groundMesh, false, true,
		mat.v3_(0.0, 0.0, 0.0),
		mat.v3_(groundRight, 0.0, 0.0),
		mat.v3_(0.0, 1.0, 0.0),
		mat.v3_(0.0, 0.0, groundBack),
		groundWidth, groundHeight,
		mat.v4_(0.0, 0.0, 10.0, 10.0),
		mat.v4_(1.0, 1.0, 1.0, 1.0))
	gfx.MeshEnd(groundMesh)
	phxGround0 = phx.AddObject(phx.TYPE_PLANE, TAG_GROUND, phx.STATE_ACTIVE | phx.STATE_DEBUG | phx.STATE_DEBUG_COLOR | phx.STATE_DEBUG_WIRE,
		mat.v3_(0.0, worldPosY, 0.0), mat.v3_(0.0, 0.0, 0.0), mat.v3_(0.0, 0.0, 0.0),
		mat.v3_(groundRight, 0.0, 0.0), mat.v3_(0.0, 1.0, 0.0), mat.v3_(0.0, 0.0, groundBack),
		0.0, mat.v4_(0.0, 1.0, 0.0, 0.0))
	phx.SetObjectRotation(phxGround0, mat.v4_(0.0, 0.0, 1.0, 0.2))
	phxGround1 = phx.AddObject(phx.TYPE_PLANE, TAG_GROUND, phx.STATE_ACTIVE | phx.STATE_DEBUG | phx.STATE_DEBUG_COLOR | phx.STATE_DEBUG_WIRE,
		mat.v3_(-100.0, 2.0 * worldPosY, 0.0), mat.v3_(0.0, 0.0, 0.0), mat.v3_(0.0, 0.0, 0.0),
		mat.v3_(groundRight, 0.0, 0.0), mat.v3_(0.0, 1.0, 0.0), mat.v3_(0.0, 0.0, groundBack),
		0.0, mat.v4_(0.0, 1.0, 0.0, 0.0))

	dollar = gfx.TextureCreate(sprintf("%s/textures/skynote.png", app.DataDir()),
		gfx.FORMAT_R8_G8_B8_A8, 0, 0, -1, false)

	texture = gfx.TextureCreate(sprintf("%s/textures/Skycoin-Cloud-BW-Vertical-on_black@2x.png", app.DataDir()),
		gfx.FORMAT_R8_G8_B8_A8, 0, 0, -1, false)
	skySpecular = gfx.TextureCreateCube(sprintf("%s/textures/skybox/", app.DataDir()), ".jpg",
		gfx.FORMAT_R8_G8_B8_A8, 0, 0, -1, false)
	skyDiffuse= gfx.TextureCreateCube(sprintf("%s/textures/irradiance/", app.DataDir()), ".png",
		gfx.FORMAT_R8_G8_B8_A8, 0, 0, -1, false)
	brdf = gfx.TextureCreate(sprintf("%s/textures/brdfLUT.png", app.DataDir()),
		gfx.FORMAT_R8_G8_B8_A8, 0, 0, 0, false)

	camera = gam.CameraCreate()
	gam.CameraSetProjection(camera, 0.1, 10000.0, 0.5, gfx.gfx_viewportSize.x, gfx.gfx_viewportSize.y, true)
	gam.CameraSetPosition(camera, mat.v3_(0.0, worldPosY + 1.0, 0.0), true)
	gam.CameraSetYawPitch(camera, 0.0, 0.0, true)

	tmpColor = resize(tmpColor, 4)
	identity = mat.MatrixIdentity(identity)
	var audioId snd.AudioId = snd.AudioCreate(sprintf("%s/audios/skycoin_baby.wav", app.DataDir()))
	voiceId = snd.VoiceCreate(audioId)

   	// exitScreen
	exitScreen  = gui.ScreenCreate("exitScreen")
	gui.ControlSetSkin(exitScreen.base, gui.g_modalSkin)
	gui.ControlSetDock(exitScreen.base, gui.DOCK_FILL)
	gui.ScreenSetDuration(exitScreen, -2.0D)
	gui.ScreenSetModal(exitScreen, true)

	{
		var exitWindow gui.WindowId = gui.WindowCreate("exitWindow")
		gui.ControlAddChild(exitScreen.base, exitWindow.base)
		gui.ControlSetSkin(exitWindow.base, gui.g_windowSkin)
		gui.ControlSetAutosize(exitWindow.base, gui.AUTOSIZE)
		gui.ControlSetAlign(exitWindow.base, gui.ALIGN_CENTER)
		gui.WindowSetCaption(exitWindow, "cxfx")
		gui.WindowAddButton(exitWindow, "no", "No", "main", "onExitDialogNo")
		gui.WindowAddButton(exitWindow, "yes", "Yes", "main", "onExitDialogYes")

		{
			var exitLabel gui.LabelId = gui.LabelCreate("exitLabel")
			gui.WindowSetContainee(exitWindow, exitLabel.base)
			gui.ControlSetDock(exitLabel.base, gui.DOCK_FILL)
			gui.ControlSetAutosize(exitLabel.base, gui.AUTOSIZE)
			gui.LabelSetFont(exitLabel, gui.g_regularFont)
			gui.LabelSetText(exitLabel, "Do you want to quit ?")
			gui.LabelSetSize(exitLabel, gui.g_fontSizeText)
			gui.LabelSetColor(exitLabel, gui.g_white)
			gui.LabelSetAlign(exitLabel, gui.ALIGN_CENTER)
		}
	}
	// mainScreen
	var mainScreen gui.ScreenId = gui.ScreenCreate("mainScreen")
	gui.ControlSetSkin(mainScreen.base, gui.g_blackSkin)
	gui.ControlSetDock(mainScreen.base, gui.DOCK_FILL)
	gui.ControlSetPadding(mainScreen.base, mat.v4_(200.0, 150.0, 200.0, 150.0))
	gui.ScreenSetDuration(mainScreen, -1.0D)
	gui.ScreenSetOnExit(mainScreen, exitScreen)
	{
		var playButton gui.LabelId = gui.LabelCreate("playButton")
		gui.ControlAddChild(mainScreen.base, playButton.base)
		gui.ControlSetSkin(playButton.base, gui.g_blueSkin)
		gui.ControlSetDock(playButton.base, gui.DOCK_TOP)
		gui.ControlSetFocusable(playButton.base, 1)
		gui.ControlSetPadding(playButton.base, mat.v4_(5.0, 5.0, 5.0, 5.0))
		gui.ControlSetAutosize(playButton.base, gui.AUTOSIZE_Y)
		gui.LabelSetFont(playButton, gui.g_boldFont)
		gui.LabelSetText(playButton, "Play")
		gui.LabelSetOnState(playButton, "main", "onPlayButton")
		gui.LabelSetSize(playButton, gui.g_fontSizeButton)
		gui.LabelSetColor(playButton, gui.g_white)
		gui.LabelSetAlign(playButton, gui.ALIGN_CENTER)

		var exitButton gui.LabelId = gui.LabelCreate("exitButton")
		gui.ControlAddChild(mainScreen.base, exitButton.base)
		gui.ControlSetSkin(exitButton.base, gui.g_blueSkin)
		gui.ControlSetDock(exitButton.base, gui.DOCK_TOP)
		gui.ControlSetFocusable(exitButton.base, 1)
		gui.ControlSetPadding(exitButton.base, mat.v4_(5.0, 5.0, 5.0, 5.0))
		gui.ControlSetAutosize(exitButton.base, gui.AUTOSIZE_Y)
		gui.LabelSetFont(exitButton, gui.g_boldFont)
		gui.LabelSetText(exitButton, "Exit")
		gui.LabelSetOnState(exitButton, "main", "onExitButton")
		gui.LabelSetSize(exitButton, gui.g_fontSizeButton)
		gui.LabelSetColor(exitButton, gui.g_white)
		gui.LabelSetAlign(exitButton, gui.ALIGN_CENTER)
	}

	// gameScreen
	gameScreen = gui.ScreenCreate("gameScreen")
	gui.ControlSetDock(gameScreen.base, gui.DOCK_FILL)
	gui.ScreenSetDuration(gameScreen, -1.0D)
	gui.ScreenSetOnExit(gameScreen, mainScreen)
	gui.ScreenSetOnEvent(gameScreen, "main", "gameOnEvent")
	gui.ScreenSetOnUpdate(gameScreen, "main", "gameOnUpdate")
	gui.ScreenSetOnRender(gameScreen, "main", "gameOnRender")

	// titleScreen
	var titleScreen gui.ScreenId = gui.ScreenCreate("titleScreen")
	gui.ControlSetSkin(titleScreen.base, gui.g_blackSkin)
	gui.ControlSetDock(titleScreen.base, gui.DOCK_FILL)
	gui.ScreenSetDuration(titleScreen, 2.0D)
	gui.ScreenSetOnNext(titleScreen, mainScreen)
	{
		var label gui.LabelId= gui.LabelCreate("titleLabel")
		gui.ControlAddChild(titleScreen.base, label.base)
		gui.ControlSetBounds(label.base, mat.v4_(0.0, 0.0, gfx.gfx_width, gfx.gfx_height))
		gui.ControlSetAlign(label.base, gui.ALIGN_CENTER)
		gui.LabelSetFont(label, gui.g_boldFont)
		gui.LabelSetText(label, app.Name())
		gui.LabelSetSize(label, gui.g_fontSizeTitle)
		gui.LabelSetAlign(label, gui.ALIGN_CENTER)
		gui.LabelSetColor(label, gui.g_gold)
	}

	// skycoinScreen
	var skycoinScreen gui.ScreenId = gui.ScreenCreate("skycoinSceen")
	gui.ControlSetSkin(skycoinScreen.base, gui.g_blackSkin)
	gui.ControlSetDock(skycoinScreen.base, gui.DOCK_FILL)
	gui.ScreenSetDuration(skycoinScreen, 2.0D)
	gui.ScreenSetOnUpdate(skycoinScreen, "main", "skycoinOnUpdate")
	gui.ScreenSetOnNext(skycoinScreen, titleScreen)
	{
		var picture PictureId = gui.PictureCreate("skycoinPicture")
		gui.ControlAddChild(skycoinScreen.base, picture.base)
		gui.ControlSetBounds(picture.base, mat.v4_(0.0, 0.0, gfx.gfx_width / 2.0, gfx.gfx_height / 2.0))
		gui.ControlSetAlign(picture.base, gui.ALIGN_CENTER)
		gui.ControlSetAutoscale(picture.base, gui.AUTOSCALE)
		gui.PictureSetAlign(picture, gui.ALIGN_CENTER)
		gui.PictureSetAnimation(picture, gui.g_skycoinAnim)
	}

	// bootScreen
	var bootScreen gui.ScreenId = gui.ScreenCreate("bootScreen")
	gui.ControlSetSkin(bootScreen.base, gui.g_bootSkin)
	gui.ControlSetDock(bootScreen.base, gui.DOCK_FILL)
	gui.ScreenSetDuration(bootScreen, 2.0D)
	gui.ScreenSetOnNext(bootScreen, skycoinScreen)

	// run
	gui.ScreenShow(bootScreen)
	gam.Run(2U)

	// destroy
	gfx.MeshUnlock(skyMesh)
	gfx.MeshUnlock(groundMesh)
	gam.Destroy()
}

